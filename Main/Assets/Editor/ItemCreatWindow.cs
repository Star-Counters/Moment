using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using System.Text;
using System.IO;
public class ItemCreatWindow : EditorWindow{
    /// <summary>
    /// Create for save the cube position list.
    /// </summary>
    private struct IntVector3 {
        public int x, y, z;
        public IntVector3(int x, int y, int z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
        public override string ToString()
        {
            return x + "," + y + "," + z;
        }
    }
    private struct IntVector2
    {
        public int x, y;
        public IntVector2(int x, int y)
        {
            this.x = x;
            this.y = y;
        }
        //public override string ToString()
        //{
        //    return x + "," + y + "," + z;
        //}
    }
    private struct RoadMap {
        List<int>[,] maps;//Holy shit..
        int xMin, zMin;
        int xLength/*width*/, zLength/*height*/;
        public RoadMap(int xMin, int zMin,int xMax,int zMax) {
            this.xMin = xMin;
            this.zMin = zMin;
            xLength = xMax - xMin + 1;
            zLength = zMax - zMin + 1;
            //col:x,row:z,value:y
            maps = new List<int>[xLength, zLength];//feel sleepy,go to bed?
        }
        public List<int> this[int x,int z]
        {
            get
            {
                return maps[x,z];
            }
            set
            {
                maps[x, z] = value;
            }
        }
        public override string ToString()
        {
            //head:

            //#xMin,zMin
            //xMin,zMin
            StringBuilder sb = new StringBuilder();
            //first line
            sb.Append("#Generated by code ItemCreatWindow,Do not modifty manually!\n");
            //second line
            sb.Append("xMin=");
            sb.Append(xMin);
            sb.Append(',');
            sb.Append("zMin=");
            sb.Append(zMin);
            sb.Append('\n');
            //content:
            for (int x = 0; x < xLength; x++) {
                for (int z = 0; z < zLength; z++) {
                    if (maps[x, z] == null)
                        sb.Append('N');
                    else
                    {
                        string valueString = ConvertArrayToString<int>(maps[x, z].ToArray());
                        sb.Append(valueString);
                    }
                    sb.Append(',');
                }
                sb.Remove(sb.Length - 1, 1);
                sb.Append('\n');
            }
            return sb.ToString();
        }
    }
    int xMin=0;
	int xMax=0;
	int zMin=0;
	int zMax=0;
	int height;
	bool groupEnabled;
	bool creatGroup;
	bool myBool = true;
	float myFloat = 1.23f;
	Transform parentRoot;
	string sceneName="Behavior";
	Object selectObj;
	Stack<List<GameObject>> undoStack = new Stack<List<GameObject>> ();
	int yRotationIndex = 0;
	string[] yRotationArray = new string[] {"0°/X轴", "90°/-Z轴", "180°/-X轴", "270°/Z轴"};
	[MenuItem ("CommonTool/Open/ItemCreatWindow")]
	static void Init () {
		ItemCreatWindow window = (ItemCreatWindow)GetWindow (typeof (ItemCreatWindow));
	}
	void OnGUI () {
		GUILayout.Label("CreatItems", EditorStyles.boldLabel);
		selectObj=EditorGUILayout.ObjectField(selectObj,typeof(GameObject),true);
		GUILayout.BeginHorizontal ();
		xMin = EditorGUILayout.IntField ("xMin",xMin);
		zMin = EditorGUILayout.IntField ("zMin",zMin);
		GUILayout.EndHorizontal ();
		height = EditorGUILayout.IntField ("y",height);
		creatGroup = EditorGUILayout.BeginToggleGroup ("IsCreatGroup",creatGroup);
		if(creatGroup){
			GUILayout.BeginHorizontal ();
			xMax = EditorGUILayout.IntField ("xMax",xMax);
			zMax = EditorGUILayout.IntField ("zMax",zMax);
			GUILayout.EndHorizontal ();
		}
		EditorGUILayout.EndToggleGroup ();
		GUILayout.BeginHorizontal ();
		GUILayout.EndHorizontal ();
		groupEnabled = EditorGUILayout.BeginToggleGroup ("Optional Settings", groupEnabled);
		yRotationIndex = GUILayout.SelectionGrid(yRotationIndex, yRotationArray, 2);
		myBool = EditorGUILayout.Toggle ("Toggle", myBool);
		myFloat = EditorGUILayout.Slider ("Slider", myFloat, -3, 3);
		sceneName = EditorGUILayout.TextField ("SceneName" , sceneName);
		EditorGUILayout.EndToggleGroup ();
		if (GUILayout.Button ("CreatItems")) {
			if(selectObj==null){
				Debug.LogError("Please select an object to creat!");
				return;
			}
			if(creatGroup){
				if(xMin>xMax)
					return;
				if(zMin>zMax)
					return;
			}
			else{	
				xMax=xMin;
				zMax=zMin;
			}
			string targetScenePath="Assets/Scenes/"+sceneName+".unity";
			if(EditorApplication.currentScene!=targetScenePath){
				EditorApplication.SaveScene();
				EditorApplication.OpenScene(targetScenePath);
			}
			parentRoot = GameObject.Find ("SceneRoot").transform.FindChild("Items_"+height);
			if(parentRoot==null){
                parentRoot = new GameObject().transform;
                parentRoot.parent = GameObject.Find("SceneRoot").transform;
                parentRoot.name = "Items_" + height;
            }
			Quaternion rotation;
			Vector3 position;
			List<GameObject> list=new List<GameObject>();
			
			//will be delete after the new models come
			float zEulerAngle=0f;
			if(selectObj.name=="Slope"){
				zEulerAngle=45f;
			}
			for(int i=xMin;i<=xMax;i++){//the x axis
				for(int j=zMin;j<=zMax;j++){//the z axis
					rotation=Quaternion.Euler(new Vector3(0,yRotationIndex*90,zEulerAngle));
					position=new Vector3(i,height,j);					                                 
					GameObject itemClone=Instantiate(selectObj,position,rotation) as GameObject;
					itemClone.transform.parent=parentRoot;
					itemClone.name=selectObj.name+"_"+i.ToString()+"_"+j.ToString();
					list.Add(itemClone);
				}
			}
			undoStack.Push(list);
		}
		if (GUILayout.Button ("Undo")) {
			if(undoStack.Count==0){
				Debug.LogWarning("Nothing to undo!");
				return;
			}
			List<GameObject> list=undoStack.Peek();
			foreach(GameObject go in list){
				DestroyImmediate(go);
			}
			undoStack.Pop();
		}
        if (GUILayout.Button("Save")) {
            Save();
            //SceneItemManager.SaveItems();
        }
	}
    void Save()
    {
        //Color[] colors = new Color[x * y * z];
        Transform sceneRoot = GameObject.Find("SceneRoot").transform;
        if (!sceneRoot) {
            Debug.LogError("Cannot find SceneRoot");
        }
        //Transform[,,] allChilds = new Transform[,,] { };//2333333333 WTF??
        List<IntVector3> posList = new List<IntVector3>(100);
        foreach (Transform yChild in sceneRoot) {
            string yName = yChild.name;
            if (yName.StartsWith("Items"))//Items_1
            {
                yName = yName.Substring(yName.IndexOf('_')+1);
                int yAxis;
                if (int.TryParse(yName,out yAxis)) {
                    foreach (Transform xzChild in yChild) {
                        string xzName = xzChild.name;
                        string[] array = xzName.Split('_');//Cube_Red_-4_-4
                        if (array.Length == 4) {
                            posList.Add(new IntVector3(int.Parse(array[2]), yAxis, int.Parse(array[3])));
                        }
                    }
                }
            }
        }
        int xMin = 0, xMax = 0, yMin = 0, yMax = 0,zMin = 0, zMax=0;
        foreach (IntVector3 v in posList) {
            xMin = Mathf.Min(xMin, v.x);
            yMin = Mathf.Min(yMin, v.y);
            zMin = Mathf.Min(zMin, v.z);
            xMax = Mathf.Max(xMax, v.x);
            yMax = Mathf.Max(yMax, v.y);
            zMax = Mathf.Max(zMax, v.z);
            //Debug.Log(v);
            //sb.Append(v);
        }
        RoadMap roadMap = new RoadMap(xMin, zMin, xMax, zMax);
        //StringBuilder sb = new StringBuilder((xMax - xMin) * (yMax - yMin) * (zMax - zMin));
        //StringBuilder sb = new StringBuilder();//TODO:for efficent.
        //Dictionary<IntVector2, int[]> finalDict = new Dictionary<IntVector2, int[]>();
        for (int x = xMin; x <= xMax; x++)
        {
            for (int z = zMin; z <= zMax; z++)
            {
                //int[] tempY = new int[];
                List<int> yList = new List<int>();
                for (int y = yMin; y <= yMax; y++)
                {
                    if (posList.Contains(new IntVector3(x, y, z)))
                        yList.Add(y);
                    //sb.Append
                }
                //if (yList.Count == 0) {

                //}
                //x<xMax    ->    x - xMin<xMax - xMin
                roadMap[x-xMin, z-zMin] = yList;
                //finalDict.Add(new IntVector2(x, z), yList.ToArray());
            }
        }
        string scenePath = EditorApplication.currentScene;
        int index = scenePath.LastIndexOf('/') + 1;
        string sceneName = scenePath.Substring(index);
        sceneName = sceneName.Replace(".unity", string.Empty);
        scenePath = scenePath.Substring(0,index);
        string filePath = Path.Combine(scenePath, sceneName+".roadmap.bytes");
        File.WriteAllBytes(filePath, Encoding.UTF8.GetBytes(roadMap.ToString()));
        Debug.Log(roadMap.ToString());
    }
    static string ConvertArrayToString<T>(T[] array)
    {
        StringBuilder sb = new StringBuilder(array.Length * 2);
        int i = 0;
        for (; i < array.Length-1; i++) {
            sb.Append(array[i]);           
            sb.Append('|');
        }
        sb.Append(array[i]);
        return sb.ToString();
    }
}
